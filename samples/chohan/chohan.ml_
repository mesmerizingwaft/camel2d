open Camel2d

let chohan = Game.create ()

module Literal = struct
  let cho = "\u{4e01}"
  let han = "\u{534a}"
  let speech = "\u{3055}\u{3042}\u{3055}\u{3042}\u{5f35}\u{3063}\u{305f}\u{5f35}\u{3063}\u{305f}\u{4e01}\u{65b9}\u{306a}\u{3044}\u{304b}\u{ff1f}\u{534a}\u{65b9}\u{306a}\u{3044}\u{304b}\u{ff1f}"
  let dice_face = [|"\u{2680}"; "\u{2681}"; "\u{2682}"; "\u{2683}"; "\u{2684}"; "\u{2685}"|]
  let win = "\u{52dd}"
  let lose = "\u{8ca0}"
end

module GameMain : Scene = struct
  (* Renderable IDs *)
  module Id = struct
    let bg = "bg"
    let fg = "fg"
    let button_cho = "button_cho"
    let button_cho_mousehover = "button_cho_mousehover"
    let button_han = "button_han"
    let button_han_mousehover = "button_han_mousehover"
    let win = "win"
    let lose = "lose"
    let dice_l = "dice_l"
    let dice_r = "dice_r"
    let speech = "speech"
  end

  let create_dice context id number ~idx =
    let open Renderable in
    let open TextLabel in
    let pt = 100 in
    let style = create_style pt in
    let pos = (chohan.width / 3 * idx, (chohan.height - pt) / 2) in
    create ~context ~style ~pos ~base_horizontal: BHCenter id Literal.dice_face.(number - 1)

  let create_label context label text =
    let open Renderable in
    let open TextLabel in
    let pt = 200 in
    let style =
      let font_face = Some "tamanegi" in
      let outline = Edging (RGBA (0, 0, 0, 1.)) in
      create_style ~font_face ~outline pt
    in
    let pos = (chohan.width / 2, (chohan.height - pt) / 2) in
    create ~context ~style ~pos ~base_horizontal:BHCenter label text

  let bg, fg =
    let open Renderable in
    let sw, sh = chohan.width, chohan.height in
    let bg = SingleImage.create Id.bg "bg" ~pos:(0, 0) ~size:(sw, sh) in
    let fg = let (w, h) = (int_of_float (0.75 *. float_of_int sh), sh) in
      SingleImage.create Id.fg "fg" ~pos:((sw - w) / 2, 0) ~size:(w, h) in
    bg, fg

  (* Logic *)
  type hand = Cho | Han
  type phase =
    | Init
    | DiceRolling of hand * int
    | End of hand * int * int
  let phase = ref Init
  let roll () = (Random.int 6) + 1
  let roll_twice () = (roll (), roll ())

  (* event handler *)
  let event_handler_init context ev renderables audios =
    let update_renderables renderables = update_scene renderables audios in
    match ev with
      | Event.MouseMove {x; y} ->
        let open RenderableUtils in
        renderables
        |> (update_when ((has_id Id.button_cho) ||| (has_id Id.button_han)) show)
        |> (update_when ((has_id Id.button_cho_mousehover) ||| (has_id Id.button_han_mousehover)) hide)
        |> (update_when (((has_id Id.button_cho) ||| (has_id Id.button_han)) &&& (is_in x y)) hide)
        |> (update_when (((has_id Id.button_cho_mousehover) ||| (has_id Id.button_han_mousehover)) &&& (is_in x y)) show)
        |> update_renderables
      | Event.MouseUp {x; y; _} ->
        let open RenderableUtils in
        Audio.resume context;
        if List.exists (has_id "button_cho" &&& is_in x y) renderables
        then phase := DiceRolling (Cho, 0);
        if List.exists (has_id "button_han" &&& is_in x y) renderables
        then phase := DiceRolling (Han, 0);
        update_renderables renderables
      | _ -> update_renderables renderables

  let event_handler_end _ ev renderables audios =
    let update_renderables renderables = update_scene renderables audios in
    match ev with
      | Event.MouseUp _ ->
        print_endline "load_new_scene";
        load_new_scene "main"
      | _ -> update_renderables renderables

  let event_handler context ev renderables audios =
    (match !phase with
      | Init -> event_handler_init
      | DiceRolling _ -> EventHandler.init
      | End _ -> event_handler_end) context ev renderables audios

  (* arbitrator *)
  let arbitrator context renderables audios =
    let update_renderables renderables = update_scene renderables audios in
    match !phase with
      | Init -> update_renderables renderables
      | DiceRolling (hand, counter) ->
        let a, b = roll_twice () in
        let dice_l = create_dice context Id.dice_l a ~idx:1 in
        let dice_r = create_dice context Id.dice_r b ~idx:2 in
        if counter <= 60
        then begin
          phase := DiceRolling (hand, counter + 1);
          update_renderables [bg; fg; dice_l; dice_r]
        end
        else begin
          phase := End (hand, a, b);
          update_renderables [bg; fg; dice_l; dice_r]
        end
      | End (hand, a, b) ->
        let label_win = create_label context Id.win Literal.win in
        let label_lose = create_label context Id.lose Literal.lose in
        let dice_l = create_dice context Id.dice_l a ~idx:1 in
        let dice_r = create_dice context Id.dice_r b ~idx:2 in
        let renderables = [bg; fg; dice_l; dice_r] in
        if hand = Cho && (a + b) mod 2 = 0
          || hand = Han && (a + b) mod 2 <> 0
        then update_renderables (renderables @ [label_win])
        else update_renderables (renderables @ [label_lose])

  let load_resources context =
    let open Promise in
    let img_root = "/samples/chohan/static/imgs/" in
    ResourceUtils.load_imgs img_root [
      ("bg", "bg.jpg");
      ("fg", "tsubofurishi.png")
    ] >>= fun resource_bucket -> 
    Audio.load_audio context "/samples/chohan/static/audio/bgm.mp3" ~is_loop:true >>= fun bgm ->
    let audio_bucket = Audio.create_bucket () in
    Hashtbl.add audio_bucket "bgm" bgm;
    return (resource_bucket, audio_bucket)

  let start context =
    let open Renderable in
    let sw, sh = chohan.width, chohan.height in
    let button_cho, button_cho_on_mousehover =
      let open TextLabel in
      let gen id color =
        let pt = 100 in
        let outline = Edging (RGBA (0, 0, 0, 1.)) in
        let font_face = Some "tamanegi" in
        let pos = ((sw / 3 - 50), (sh - 100)/2) in
        let style = TextLabel.create_style ~color ~outline ~font_face pt in
        create ~context ~style ~pos id Literal.cho
      in
      gen Id.button_cho (RGBA (255, 255, 255, 1.)),
      gen Id.button_cho_mousehover (RGBA (255, 200, 200, 1.)) in
    let button_han, button_han_on_mousehover =
      let open TextLabel in
      let gen id color =
        let pt = 100 in
        let outline = Edging (RGBA (0, 0, 0, 1.)) in
        let font_face = Some "tamanegi" in
        let pos = ((sw / 3 * 2 - 50), (sh - 100)/2) in
        let style = TextLabel.create_style ~color ~outline ~font_face pt in
        create ~context ~style ~pos id Literal.han
      in
      gen Id.button_han (RGBA (255, 255, 255, 1.)),
      gen Id.button_han_mousehover (RGBA (255, 200, 200, 1.)) in
    let speech =
      let open TextLabel in
      let style =
        let font_face = Some "tamanegi" in
        let outline = Edging (RGBA (0, 0, 0, 1.)) in
        create_style ~font_face ~outline 25
      in
      create ~context ~style ~pos:((sw - 25 * 21) / 2, 20) Id.speech Literal.speech
    in
    Random.self_init ();
    phase := Init;
    let renderables = [ bg; fg; speech; button_cho; button_cho_on_mousehover; button_han; button_han_on_mousehover ] in
    let audios = [] in
    renderables, audios, arbitrator, event_handler
end

let _ =
  Game.add_scene chohan "main" (module GameMain);
  start chohan "main" 
